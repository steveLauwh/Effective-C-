## 条款41：了解隐式接口和编译期多态

* 面向对象编程世界总是以显示接口 explicit interface 和运行期多态 runtime polymorphism 解决问题。
* class 和 template 都支持接口和多态。
* 对 class 而言接口是显式的，以函数签名为中心。多态则是通过 virtual 函数发生于运行期。
* 对 template 参数而言，接口是隐式的，奠基于有效表达式。多态则是通过 template 具现化和函数重载解析发生于编译期。

## 条款42：了解 typename 的双重意义

* 任何时候当你想要在 template 中指涉一个嵌套从属类型名称，就必须在紧临它的前一个位置放上关键字 typename。

```
template <typename C>
void print2nd(const C& container)
{
  if (container.size() >= 2)
  {
      typename C::const_iterator iter(container.begin());
  }
}
```

* 声明 template 参数时，前缀关键字 class 和 typename 可互相换。
* 请使用关键字 typename 标识嵌套从属类型名称，但不得在 base class list 或 member initialization list 内以它作为 bass class 修饰符。

```
template <typename T>
class Derived : public Base<T>::Nested {  // base class list，不允许 “typename”
public:
  explicit Derived(int x) : Base<T>::Nested(x)  // mem. init. list 中，不允许 “typename”
  {
      typename Base<T>::Nested temp;` 
  }
};
```

## 条款43：学习处理模板化基类内的名称

* 可在 derived class template 内通过 “this->” 指涉 base class template 内的成员名称，或由一个明白写出的 “base class 资格修饰符” 完成。

## 条款44：将与参数无关的代码抽离 template

## 条款45：运用成员函数模板接受所有兼容类型

## 条款46：需要类型转换时请为模板定义非成员函数

## 条款47：请使用 trait class 表现类型信息

## 条款48：认识 template 元编程
