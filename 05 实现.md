## 条款26：尽可能延后变量定义式的出现时间

* 尽可能延后变量定义式的出现，这样做可增加程序的清晰度并改善程序效率。

```cpp
// 方法A：定义于循环外，1个构造函数 + 1个析构函数 + n个赋值操作
Widget w;
for (int i = 0; i < n; i++) {
  w = 取决于 i 的某个值;
  ...
}

// 方法B：定义于循环内，n个构造函数 + n个析构函数
for (int i = 0; i < n; i++) {
  Widget w(取决于 i 的某个值);
  ...
}
```

## 条款27：尽量少做转型动作

* C++ 提供四种新式转型

  (1) const_cast<T>(expression)：通常被用来将对象的常量性转除。
  
  (2) dynamic_cast<T>(expression)：主要用来执行“安全向下转型”，也就是用来决定某对象是否归属继承体系中的某个转型。
  
  (3) reinterpret_cast<T>(expression)：意图执行低级转型，实际动作可能取决于编译器，不可移植。
  
  (4) static_cast<T>(expression)：用来强迫隐式转换。

* 如果可以，尽量避免转型，特别是在注重效率的代码中避免 dynamic_cast。如果有个设计需要转型动作，试着发展无需转型的替代设计。
* 如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需将转型放进自己的代码中。
* 宁可使用 C++ style 转型，不要使用旧式转型。前者很容易辨识出来。

## 条款28：避免返回 handles 指向对象内部成分

* 避免返回 handle(包括 reference、指针、迭代器) 指向对象内部。遵守这个条款可增加封装性，帮助 const 成员函数的行为像个 const，
  并将发生 dangling handle 的可能性降至最低。

## 条款29：为 “异常安全” 而努力是值得的

* 当异常被抛出时，带有异常安全性的函数会：
  
  (1) 不泄漏任何资源。
  
  (2) 不允许数据败坏。
  
* 异常安全函数提供一下三个基本保证：
  
  (1) 基本承诺：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。没有任何对象或数据结构会因此而破坏。
  
  (2) 强烈保证：如果异常被抛出，程序状态不改变。
  
  (3) 不 nothrow 保证：承诺绝不抛出异常。
  
* 异常安全函数即使发生异常也不会泄漏资源或允许任何数据结构破坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛出异常型。
* “强烈保证” 往往能够以 copy-and-swap 实现出来，但 “强烈保证” 并非对所有函数都可以实现或具备现实意义。
* 函数提供的 “异常安全保证” 通常最高只等于其所调用之各个函数的 “异常安全保证” 中的最弱者。

## 条款30：透彻了解 inlining 的里里外外

* 明确声明 inline 函数的做法是在其定义式前加上关键字 inline。
* 将大多数 inlining 限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级更容易，
  也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。
* 不要只因为 function template 出现在头文件，就将它们声明为 inline。

## 条款31：将文件间的编译依存关系降至最低

* 将接口从实现中分离。
* 如果使用 object reference 或 object pointer 可以完成任务，就不要使用 object。
* 如果能够，尽量以 class 声明式替换 class 定义式。
* 为声明式和定义式提供不同的头文件。
* 支持 “编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是 Handle class 和 Interface class。
* 程序库头文件应该以 “完全且仅有声明式” 的形式存在。这种做法不论是涉及 template 都适用。
