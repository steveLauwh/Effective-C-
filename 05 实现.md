## 条款26：尽可能延后变量定义式的出现时间

* 尽可能延后变量定义式的出现，这样做可增加程序的清晰度并改善程序效率。

```
// 方法A：定义于循环外，1个构造函数 + 1个析构函数 + n个赋值操作
Widget w;
for (int i = 0; i < n; i++) {
  w = 取决于 i 的某个值;
  ...
}

// 方法B：定义于循环内，n个构造函数 + n个析构函数
for (int i = 0; i < n; i++) {
  Widget w(取决于 i 的某个值);
  ...
}
```

## 条款27：尽量少做转型动作

* C++ 提供四种新式转型

  (1) const_cast<T>(expression)：通常被用来将对象的常量性转除。
  
  (2) dynamic_cast<T>(expression)：主要用来执行“安全向下转型”，也就是用来决定某对象是否归属继承体系中的某个转型。
  
  (3) reinterpret_cast<T>(expression)：意图执行低级转型，实际动作可能取决于编译器，不可移植。
  
  (4) static_cast<T>(expression)：用来强迫隐式转换。

* 如果可以，尽量避免转型，特别是在注重效率的代码中避免 dynamic_cast。如果有个设计需要转型动作，试着发展无需转型的替代设计。
* 如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需将转型放进自己的代码中。
* 宁可使用 C++ style 转型，不要使用旧式转型。前者很容易辨识出来。

## 条款28：避免返回 handles 指向对象内部成分

* 避免返回 handle(包括 reference、指针、迭代器) 指向对象内部。遵守这个条款可增加封装性，帮助 const 成员函数的行为像个 const，
  并将发生 dangling handle 的可能性降至最低。

## 条款29：为 “异常安全” 而努力是值得的

## 条款30：透彻了解 inlining 的里里外外

## 条款31：将文件间的编译依存关系降至最低
