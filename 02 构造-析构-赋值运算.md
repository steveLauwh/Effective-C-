## 条款 05：了解 C++ 默默编写并调用哪些函数

* 编译器可以暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符，以及析构函数。
* 编译器默认创建这些函数是 public 且 inline。
* 如果打算在一个“内含 reference 成员”的 class 内支持赋值操作，必须自定义 copy assignment 操作符。

```
template<class T>
class NamedObject {
public:
  NamedObject(std::string& name, const T& value);
  ...
private:
  std::string& nameValue;  // reference 成员
  const T objectValue;     // const 成员
};
```

## 条款 06：若不想使用编译器自动生成的函数，就该明确拒绝

* 为驳回编译器自动(暗自)提供的机能，可将相应的成员函数声明为 private 并且不予实现。
  使用像 Uncopyable 这样的 base class 也是一种做法。
```
class Uncopyable {
protected:
  Uncopyable() {}
  ~Uncopyable() {}
private:
  Uncopyable(const Uncopyable&);     // 阻止 copying
  Uncopyable& operator=(const Uncopyable&);
};

// 为求阻止 HomeForSale 对象被拷贝
class HomeForSale : private Uncopyable {
  ...
};
```

## 条款 07：为多态基类声明 virtual 析构函数

## 条款 08：别让异常逃离析构函数

## 条款 09：绝不在构造和析构过程中调用 virtual 函数

## 条款 10：令 operator= 返回一个 reference to *this

## 条款 11：在 operator= 中处理“自我赋值”

## 条款 12：复制对象时勿忘其每一个成分
